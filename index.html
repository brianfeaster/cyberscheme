<!DOCTYPE html>
<html><style type="text/css">

p,div { padding:0; border:0; margin:0; }

body {
  display:flex;
  flex-direction: column;
  width: 100vw;
  height: 100vh;
  justify-content:center;
  align-items:center;
  background-color:black;
  background-image:url("bg/cyberwarpcore.jpg");
  background-size:cover;
  background-position:center;
  background-attachment:fixed;
  font-family:monospace;
  color: #0f0;
  cursor: unset;
  padding: 0; border:0; margin: 0;
}

#uxcontainer {
  position: relative;
  width: 90%;  height: 90%;
  background-color: #000e;
  border: outset 1ch grey;
}

#editor {
  height: 70%;
  width: 100%;
  white-space: pre;
  overflow: auto;
  outline: 0 solid transparent;
  opacity: 0;
}

#vt100parent {
  height: calc(30% - 1em);
  border: inset 1ch grey;
}

#vt100 {
  word-break: break-all;
  overflow: auto;
  height: 100%;
}
/* em pc ch ex px | in cm mm  pt */
#clock {
  display: none;
  position: absolute;
  text-align:center;
  width: 5ch;
  padding: 0ex 1ex 0ex 1ex;
  background-color: #100;
  color: #ff0000;
  filter: blur(0.7px);
}

#console {
  position: relative;
  top: 1ex;
  width: 95%;
  border: solid thick grey;
  background: black;
  color: white;
  margin: 1ex;
  display:none;
}

#knobsleft {
  display: inline-block;
  float: left;
  text-align: left;
}

#knobsright {
  display: inline-block;
  float: right;
  text-align: right;
}

#knobsleft > p {
  display: inline-block;
  margin-right: 1ch;
  background-color: #f4f8;
  color: #0ff;
}

#knobsright > p {
  display: inline-block;
  margin-left: 1ch;
  background-color: #f4f8;
  color: #0ff;
}

.js { display: none; }

</style><head><title>Cyber&trade;Scheme</title></head><body>

<div id="console">Cyber&trade;Scheme:1.0</div>

<div style="width:95%">

  <div id="knobsleft">
   <p id="knobreload" style="display:none">rst</p>
  </div>

  <div id="knobsright">
   <p id="knobjs">js</p>
  </div>

</div>


<div id="uxcontainer">
 <p id="editor" contenteditable>x
( (lambda (f) (f x))
  (lambda (n) (+ n n)) )
</p>
 <div id="vt100parent"><p id="vt100"></p></div>
 <p id="clock">12:00</p>
</div>

</body><script id="scanner" type="javascript/worker">//<![CDATA[
"use strict"

function log () { console.log(...arguments); }

function makeStatesTable (desc) {
  let states = Array.from(new Array(257), (_)=>desc[0]); // table initialied with default state
  for (let i=1; (i < desc.length); i+=2) {
    desc[i]
      .split("")
      .forEach( (c) => states[c.charCodeAt()] = desc[i+1] );
  }
  return states;
}

function makeStateMachine (...args) {
  let table = [];
  for (let i=0; (i < args.length); i+=2) {
    table[args[i]] = makeStatesTable(args[i+1]);
  }
  return table;
}

// Intermediate states
let Start=0, Comment=1, White=2, Dot=3, Dash=4, Floatsym=5, Num=6, Float=7, Sym=8, Str=9;
// Final states
let QUOTE=201, OPEN=202, CLOSE=203, STR=204, EOF=998, ERROR=999;
// Final states requiring unget
let DOT=1002, NUM=1003, FLOAT=1004, SYM=1005, COMMENT=1098, WHITE=1099;

let fsm = makeStateMachine(
  Start, [ERROR,
          ";",Comment, "\b\t\n\v\f\r ",White, ".",Dot, "-",Dash, "0123456789",Num, "'",QUOTE, "([{",OPEN, ")]}",CLOSE,
          "\"",Str, "!$%@*+/:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_abcdefghijklmnopqrstuvwxyz|~",Sym,
          "\u0100",EOF],
  Comment, [Comment, "\n\u0100",COMMENT],
  White,   [WHITE, "\b\t\n\v\f\r ",White],
  Dot,     [DOT, "0123456789",Float,             "!$%@*+-./:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_abcdefghijklmnopqrstuvwxyz|~",Sym],
  Dash,    [SYM, ".",Floatsym, "0123456789",Num,  "!$%@*+-/:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_abcdefghijklmnopqrstuvwxyz|~",Sym],
  Floatsym,[SYM, "0123456789",Float,             "!$%@*+-./:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_abcdefghijklmnopqrstuvwxyz|~",Sym],
  Num,     [NUM, "0123456789",Num, ".",Float,     "!$%@*+-/:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_abcdefghijklmnopqrstuvwxyz|~",Sym],
  Float,   [FLOAT, "0123456789",Float,           "!$%@*+-./:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_abcdefghijklmnopqrstuvwxyz|~",Sym],
  Sym,     [SYM,                       "!$%@*+-./0123456789:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_abcdefghijklmnopqrstuvwxyz|~",Sym],
  Str,     [Str, "\"\u0100",STR]
);

let text="", start=0, ptr=0, state=Start;
function DB () { log([start, ptr, ...token()]); }
function init (txt) { text=txt;  start = ptr = state = 0; };
function getc () { return text.length<=ptr ? 256 : text.charCodeAt(ptr++); }
function ungetc () { 0<ptr && ptr--;  }
function isFinalState () { return 100 <= state; }
function isFinalUngetState () { return 1000 <= state; }
function isUseableToken () { return (state%100) < 50; }
function token () {
  return [
    state,
    state==EOF ? "#eof" : text.substr(start, ptr-start)
  ];
};
function reset () { state=Start; start=ptr; }
function eof () { return state == EOF; }
function scanNextToken () {
  isFinalState() && reset(); // Reset state machine if called from a final state.
  let c;
  while (!isFinalState()) { state = fsm[state][c=getc()]; }
  if ( isFinalUngetState() && c!=256 ) { ungetc(); } // Maybe unget last char but only if not EOF
  return token();
}

onmessage = function (e) {
  init(e.data);
  let tokens = [];
  while (!eof()) { tokens.push(...scanNextToken()); }
  postMessage(tokens);
};

log("WebWorker listening: scanner");

//]]></script> <script id="parser" type="javascript/worker">//<![CDATA[
"use strict"

function log (...args) { console.log(...args); }
function Pair (a,b) { this.car = a; this.cdr = b; }

let QUOTE=201, OPEN=202, CLOSE=203, STR=204, EOF=998, ERROR=999;
let DOT=1002, NUM=1003, FLOAT=1004, SYM=1005, COMMENT=1098, WHITE=1099;

function parse (tokens) {
  if (tokens.length < 2) { return null; }
  switch (tokens[0]) { case WHITE : case COMMENT : tokens.shift(); tokens.shift(); return parse(tokens); }
  let tok = tokens.shift();
  let txt = tokens.shift()
  switch (tok) {
    case OPEN : return parseList(tokens);
    case CLOSE : return null;
    case QUOTE : return new Pair("quote", new Pair(parse(tokens), null));
    case NUM :
    case FLOAT : return parseFloat(txt);
    case EOF : return undefined;
    default : return txt;
  }
}

function parseList (tokens) {
  if (tokens.length < 2) { return null; }
  switch (tokens[0]) {
    case WHITE :
    case COMMENT :
      tokens.shift();
      tokens.shift();
      return parseList(tokens);
  }
  let tok = tokens.shift();
  let txt = tokens.shift();
  switch (tok) {
    case OPEN : return new Pair(parseList(tokens), parseList(tokens));
    case CLOSE : return null;
    case EOF: return null;
    case DOT : let ret = parse(tokens);
               if (ret === undefined) { ret = null; }
               if (tokens[0]==CLOSE) {
                 tokens.shift(); // TODO assume/consume CLOSE
                 tokens.shift();
               }
               return ret;
    case QUOTE : return new Pair(new Pair("quote", new Pair(parse(tokens), null)), parseList(tokens));
    default : tokens.unshift(txt);
              tokens.unshift(tok);
              let a = parse(tokens);
              return new Pair(a, parseList(tokens));
  }
}

onmessage = function (e) {
  let tokens = e.data;
  let result = [];
  while (0 < tokens.length) { result.push(parse(tokens)); }
  postMessage(result);
};


log("WebWorker listening: parser");

//]]></script> <script type="text/javascript">//<![CDATA[
"use strict";

[...(new Array(20))].forEach( (e,i)=>console.log(i));

const $ = document.querySelector.bind(document);

function str (o) { return JSON.stringify(o); };
function indent (l) { return l ? "\n"+Array(l+1).join(" ") : ""; };
Object.prototype.str = function () { return str(this); };
Array.prototype.isEmpty = function () { return 0==this.length; };
function log (...args) {
  //return; // COMMENT THIS TO ENABLE CONSOLE DEBUGGING
  console.log((this === undefined ? "" : this.str()) + args);
};
function rnd (n) { return Math.floor(n*Math.random()); };
function min (a,b) { return Math.min(a,b); }
window.HTMLElement.prototype.NewChild = function (tag, text) {
  const e = this.appendChild(document.createElement(tag));
  if (text !== undefined) { e.innerText = text; }
  return e;
};
Date.prototype.duration = function () { return new Date() - this; }
  
window.HTMLElement.prototype.AddClass = function (className) {
  this.classList.add(className);
  return this;
};

function CreateAppendChild (tag, parent, text) {
  const e = parent.appendChild(document.createElement(tag));
  if (text !== undefined) { e.innerText = text; }
  return e;
};
const _ = undefined;
const CHAR_DOT = String.fromCharCode(183);
const Uxcontainer = $("#uxcontainer");
const Console = $("#console");
const Clock = $("#clock");
const Editor = $("#editor")
const Vt100 = $("#vt100");
const ClassStylejs = [...document.styleSheets[0].cssRules].filter((e)=>e.selectorText=='.js')[0].style;

////////////////////////////////////////////////////////////////////////////////
// Preemptive Concurrent Monadic Thread Sequence Process Scheduler

function Actor (stage, fn, ...args) {
  this.id     = rnd(1000);
  this.stage  = stage;
  this.interval = 0;
  this.next   = undefined;
  this.fn     = fn;
  this.args = [...args];
  this.scheduled = false;
  this.result = undefined;
  log.bind("NEW")(this.str());
}

Actor.prototype.str = function (level=0) {
  return indent(level)
    +  `Actor:${this.id}/${this.stage && this.stage.id}{ `
    + `${str([this.fn.name, ...this.args])} ${this.interval}/${this.next}`
    + (this.scheduled ? " SCHEDULED" : "")
    + ` ->${str(this.result)} }`
};

Actor.prototype.delay = function (interval) {
  this.interval = interval;
  return this;
}

Actor.prototype.action = function () {
  this.next = Date.now();
  this.stage.play.actors.push(this);
  return this;
}

Actor.prototype.schedule = function (fn, ...args) {
  this.cont(fn, ...args);
  this.scheduled = true;
  return this.wake.bind(this);
}

Actor.prototype.wake = function (...args) {
  if (this.result !== undefined) {
    console.error("Actor is retired: " + this.str());
    return this;
  }
  this.next = Date.now();
  this.scheduled = false;
  this.args.push(...args);
  this.stage.play.actors.push(this);
  this.stage.play.running || this.stage.play.run();
  return this;
}

Actor.prototype.step = function () {
  if (this.result === undefined) {
    this.result = this.fn(...this.args);
    this.next += this.interval;
  } else {
    console.error(`Already returned  ${this.str()} `);
  }
}

Actor.prototype.cont = function (fn, ...args) {
  if (fn) { this.fn = fn; };
  this.args = args;
}


//////////////////// Actor Scene Troop Play Guild

function Stage (play) {
  this.id = rnd(1000);
  this.play = play;
  this.stage = undefined;
  this.acting = false;
  this.actor = undefined;
  this.elements = [];
  this.nextStage = undefined;
  this.result  = undefined;
  log.bind("NEW")(`Stage:${this.id}`+this.str());
};

Stage.prototype.str = function () {
  //let els = this.elements.map( (e)=>a.str() );
  //return `Stage:${this.id}{${els}}`
  return `[`
    + this.elements.filter((e)=>e.constructor===Actor).map((e)=>e.id).join(" ") +
    this.elements.filter((e)=>e.constructor===Stage).map((e)=>e.str()).join(" ") +
    "]" +
    (this.nextStage?"."+this.nextStage.str():"");
};

Stage.prototype.scene = function () {
  let s = new Stage(this.play);
  s.stage = this;
  s.acting = this.acting;
  this.elements.push(s);
  return s;
}

Stage.prototype.and = function (fn, ...args) {
  this.elements.push(this.actor = new Actor(this, fn, ...args));
  if (this.acting) { this.actor.action(); }
  return this;
}

Stage.prototype.delay = function (d) {
  this.actor.delay(d);
  return this;
}

Stage.prototype.then = function (fn, ...args) {
  let s = new Stage(this.play);
  s.stage = this;
  s.and(fn, ...args);
  this.nextStage = s;
  return s;
}

Stage.prototype.action = function () {
  this.acting = true;
  this.elements.forEach( (e)=>e.action() );
  return this;
};

Stage.prototype.del = function (e) {
  let idx = this.elements.findIndex( (a)=>a===e );
  if (0 <= idx) {
    this.elements.splice(idx, 1);
  }
  if (this.elements.isEmpty()) {
    if (this.nextStage) {
      this.elements.push(this.nextStage.action());
      this.nextStage = undefined;
    } else {
      this.stage && this.stage.del(this); // remove this stage from parent (unless main stage)
    }
  }
  return this;
}


////////////////////////////////////////

function Play () {
  this.id = rnd(1000);
  this.power = false;
  this.running = false;
  this.main = new Stage(this).action();
  this.stage = this.main;
  this.actors = [];
};

Play.prototype.str = function () {
    return `Play:${this.id}{`
      //+ this.actors.map((a)=>a.str(1)).join("")
      + this.actors.map((a)=>a.id).join(" ")
      + " " + this.main.str()
      + '}';
};

Play.prototype.scene = function () {
  this.stage = this.stage.scene();
  return this;
};

Play.prototype.up = function () {
  if (this.stage === this.main) {
    console.error("Can't up from main stage.");
  } else {
    this.stage = this.stage.stage;
  }
  return this;
};

Play.prototype.and = function (f, ...args) {
  this.stage.and(f, ...args);
  if (this.power && 1==this.actors.length) { this.run(); }
  return this;
};

Play.prototype.delay = function (d) {
  this.stage.delay(d);
  return this;
};

Play.prototype.then = function (fn, ...args) {
  this.stage = this.stage.then(fn, ...args);
  return this;
}

Play.prototype.run = function () {
  if (this.running) { log("Already running: " + this.str()); return this; }
  let idx=0;
  let next = Number.MAX_SAFE_INTEGER;
  this.running = true;
  //log("IN...");
  while (this.actors.length) {
    const now = Date.now();
    if (this.actors.length <= idx) { // Considered every actor.
      //log(this.str());
      if (now < next) { // Schedule next sleeping
        setTimeout(this.run.bind(this), next-now);
        //log(`sleeping ${next-now}...`);
        break;
      } else { // Start from the beginning
        idx = 0;
        next = Number.MAX_SAFE_INTEGER;
      }
    } else {
      let actor = this.actors[idx];
      log.bind(`${actor.id} `)(this.str());
      if (actor.next <= now) { // STEP ACTOR
        actor.step();
        if (actor.result !== undefined) { // ACTOR FINISHED, DELETE IT
          log("Actor is retiring: " + actor.str());
          this.actors.splice(idx, 1);
          actor.stage.del(actor);
          continue;
        } else if (actor.scheduled) {
          this.actors.splice(idx, 1);
          continue;
        }
      }
      ++idx;                   // ROUND ROBIN
      next = min(next, actor.next);
    }
  }
  //log("OUT.");
  this.running = false;
  return this;
}

Play.prototype.start = function () {
  this.power = true;
  this.run();
}

////////////////////////////////////////

let scanner = new Worker(
  URL.createObjectURL(
    new Blob(
      [$("#scanner").textContent],
      { type: "text/javascript"})));

let parser = new Worker(
  URL.createObjectURL(
    new Blob(
      [$("#parser").textContent],
      { type: "text/javascript"})));

let QUOTE=201, OPEN=202, CLOSE=203, STR=204, EOF=998, ERROR=999;
let DOT=1002, NUM=1003, FLOAT=1004, SYM=1005, COMMENT=1098, WHITE=1099;

let tokenClr = new Map([
  [OPEN,"yellow"], [CLOSE,"yellow"], [STR,"brown"], [EOF,"orange"], [ERROR, "red"], [DOT,"blue"], [NUM,"green"], [FLOAT,"lawngreen"], [SYM,"mediumpurple"], [COMMENT,"bisque"], [WHITE,"white"]]);

function Pair (a,b) { this.isPair = true; this.car = a; this.cdr = b; }

function disp (o, isPair) {
  let ret = "";
  if (null === o) {
    ret += isPair ? "" : "()";
  } else if (undefined === o) {
    ret += (isPair ? " . " : "") + "#undefined";
  } else {
    switch (o.constructor) {
      case Array :
        ret += "#[" + o.map( (o) => disp(o, false) ).join(" ") + "]";
        break;
      case Object :  // Pair
        if (!isPair) { ret += "("; }
        ret +=  disp(o.car, false) + (o.cdr===null || o.cdr===undefined ? "" : o.cdr.constructor===Object ? " " : " . ") + disp(o.cdr, true);

        if (!isPair) { ret +=  ")"; }
        break;
      case Number : ret += o; break;
      case String : ret += o; break;
      default :
        ret += (isPair ? "" : " . ") + JSON.stringify(o); break;
    }
  }
  return ret;
}

function dumpRawTokens (tokens, duration) {
  // Dump raw tokens for fun
  Vt100.innerText = "";
  for (let i=0; (i < tokens.length); i+=2) {
    let tok = tokens[i];
    let txt = tok==WHITE ? CHAR_DOT : tokens[i+1];
    CreateAppendChild("span", Vt100, txt).style.color = (tokenClr.get(tok) || "blue");
  }
  // Token scanning stats
  CreateAppendChild( "i", Vt100, ` ${tokens.length/2} token${tokens.length/2==1?"":"s"} ${duration}ms\n`)
    .style.color = "grey";
  Vt100.scrollTo(0, Vt100.scrollHeight - Vt100.clientHeight);
}

let parseCount = 0;
let lastParsed = [];

function sexpr2ary (sexpr) {
  let ret = [];
  while (sexpr && sexpr.constructor) {
    ret.push(sexpr.car);
    sexpr = sexpr.cdr;
  }
  return ret;
}

// Returns string of JS code.
function evaluate1 (e) {
  if (null === e) { return "null"; }

  if (e.constructor !== Object) { // Not a pair
    if (Number === e.constructor) { // Number
      return e;
    } else if (String === e.constructor && e.at(0) != '"') { // Symbol
      return `env["${e}"]`;
    } else { // String (already includes quotes)
      return e;
    }
  }

  let cmd = e.car;
  let params = e.cdr;

  if (cmd == "quote") { return str(params.car); }
  if (cmd == "set!") {
     return `(env["${params.car}"]=${evaluate1(params.cdr.car)})`;
  }
  if (cmd == "lambda" && params && params.constructor === Object) {
    if (params.car === null && params.cdr && params.cdr.constructor === Object) {
      let body = sexpr2ary(params.cdr).map( (e)=>evaluate1(e) ).join(",");
      return `(function () { return (${body}); })`;
    }
    if (params.cdr && params.cdr.constructor === Object && params.cdr.car) {
      let args = sexpr2ary(params.car);
      let body = sexpr2ary(params.cdr).map( (e)=>evaluate1(e) ).join(",");
      return `(function (${args.join(",")}) { let env=Object.create(this, {}); ${ args.map( (e)=>"env."+e+"="+e).join("; ")}; return (${body}); }.bind(env))`;
    }
  } else {
  }

  let args = [];
  while (params && params.constructor === Object) {
    args.push(evaluate1(params.car));
    params = params.cdr;
  }

  switch (e.car) {
    case "+" : return "(" + (args.join("+")||0) + ")"; break;
    case "-" : return "(" + (args.join("-")||0) + ")"; break;
    case "*" : return "(" + (args.join("*")||1) + ")"; break;
    case "/" : return "(" + (args.join("/")||1) + ")"; break;
    default  : return evaluate1(e.car) + "(" + args.join(",") + ")";
  }
}

/* TGE */
let env = {x:1};

function evaluate (sexprs) {
  sexprs.forEach( (e)=>{
    let expr, val ;
    if (e !== undefined) {
      try { expr = evaluate1(e); } catch(err) { expr = `"ERROR: ${err}"` };
      try { val = Function(`return ${expr}`)(); } catch(e) { val = e.message; };
      Vt100.NewChild("b", `${expr}\n`).AddClass("js").style.color="darkmagenta"; // indigo
      Vt100.NewChild("b", `${disp(e)}\n`);
      Vt100.NewChild("b", `${disp(val)}\n`).style.color="cyan";
    }
    Vt100.scrollTo(0, Vt100.scrollHeight - Vt100.clientHeight);
  } );
  return "Done.";
}

function parseAndEvaluate (start, tokens, sexpr) {
  if (tokens === undefined) {
    if (parseCount++) { return "Scheduled evaluation..."; };
    scanner.onmessage = this.schedule(this.fn, new Date());
    scanner.postMessage(Editor.innerText);
    return;
  } else if (sexpr === undefined) {
    tokens = tokens.data;
    let now = new Date();
    //Vt100.innerText = "";
    //dumpRawTokens(tokens, start.duration());
    parser.onmessage = this.schedule(this.fn, now, tokens);
    parser.postMessage(tokens);
    return;
  }
  sexpr = sexpr.data;
  Vt100.innerText = "";
  CreateAppendChild("i", Vt100, `${sexpr.length} sexpr${sexpr.length==1?"":"s"} ${start.duration()}ms\n`).style.color = "grey";
  Vt100.scrollTo(0, Vt100.scrollHeight - Vt100.clientHeight);
  evaluate(lastParsed = sexpr);
  return (1 < parseCount)
    ? (parseCount=0, this.cont(this.fn))
    : (parseCount=0, "Done evaluating.");
}

////////////////////////////////////////////////////////////////////////////////
function loadGist (event) {
  if (event === undefined) {
    let gistpath = new URLSearchParams(window.location.search).get("gist");
    if (gistpath) {
      let req = new XMLHttpRequest();
      req.overrideMimeType("application/json");
      req.open("GET", `https://api.github.com/gists/${gistpath}`, true);
      req.onreadystatechange = this.schedule(this.fn);
      req.send(null);
      return; // Scheduled this callback.
    }
    return "Gist path empty.";
  } else {
    let req = event.target;
    if (req.readyState === 4) {
      if (req.status != "200") {
        return "Unable to access gist.";
      } else {
        let theText = Object.values(JSON.parse(req.responseText).files)[0].content;
        Editor.innerText = theText;
        return "Gist completed";
      }
    }
    this.schedule(this.fn);
    return; // Try again
  }
}

function resizeBox (size, max) {
  Uxcontainer.style.width = size + "%";
  Uxcontainer.style.height = size + "%";
  this.interval = ((100-size)/5);
  if (size <= max) {
    this.cont(resizeBox, size+1, max)
  } else {
    return "Done.";
  }
}

function revealCode (clr) {
  Editor.style.opacity = clr/100;
  if (clr < 100) {
    this.cont(revealCode, clr+1)
  } else {
    return "Done.";
  }
}

function clockAnimate (x, y, xi, yi) {
  if (Clock.style.display == "none") { return "Done."; }

  Clock.style.display = "inherit";
  Clock.style.left = `${x}px`;
  Clock.style.top = `${y}px`;

  x += xi;  y += yi;
  let r = Uxcontainer.clientWidth - Clock.clientWidth - 1;
  let b = Uxcontainer.clientHeight - Clock.clientHeight - 1;
  if (x < 0) { x=1; xi*=-1; }
  if (y < 0) { y=1; yi*=-1; }
  if (r < x) { x=r-1; xi*=-1; }
  if (b < y) { y=b-1; yi*=-1; }
  let d = new Date();

  Clock.innerText =
    ("0" + d.getHours()%12).slice(-2)
    + (d.getMilliseconds()%1000<500?":":" ")
    + ("0" + d.getMinutes()).slice(-2);
  this.cont(clockAnimate, x, y, xi, yi);
};

////////////////////////////////////////

function countDown (a, b, i) {
  Editor.innerText += a;
  if (a <= b) {
    //setTimeout(this.schedule(this.fn, a+i, b, i), 200);
    this.cont(this.fn, a+i, b, i);
    return;
  }
  return 69;
}

let play = new Play()
/*
  .and(countDown, 0, 10, 1).delay(50)
*/
  .and(loadGist)
  .and(resizeBox, 0, 90)
  .then(revealCode, 0).delay(1)
/*
  .scene()
    .up()
  .up()
  .then(clockAnimate, 0, 0, 5,5).delay(100)
*/
  .then(parseAndEvaluate)
/*
    .then(function clockDone(){console.log("clock done");return"done";}).delay(1000)
    .up()
  .up()
*/
;

play.start();

Editor.onkeyup = ()=> {
  if (event.key=="Enter" && event.altKey) {
  } else if (event.key!="Shift" && event.key!="Alt") {
    play.and(parseAndEvaluate); // Every keypress forces re-evaluation
  }
};

Editor.focus();

Clock.onmousedown = ()=> Clock.style.display="none";

$("#knobjs").onmousedown=((s)=>(e)=>{
  ClassStylejs.display = (s=!s) ? "flex" : "none";
  e.srcElement.style.textTransform = s ? "uppercase" : null;
})();

// A mouse-over trigger to reload the page.
setTimeout(()=>$("#knobreload").style.display=null, ($("#knobreload").onmouseover=()=>location.reload($("#knobreload").style.display="none"),1000));

//]]></script></body></html>
